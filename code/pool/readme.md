# 线程池和连接池

## 1.threadpool.h
使用线程池可以减少线程的销毁，而且如果不使用线程池的话，来一个客户端就创建一个线程。这样线程的创建、线程之间的调度也会耗费很多的系统资源，所以采用线程池使程序的效率更高。  
线程池就是项目启动的时候，就先把线程池准备好。一般线程池的实现是通过生产者消费者模型来的。  
线程同步问题涉及到了互斥量、条件变量。在代码中，将互斥锁、条件变量、关闭状态、工作队列封装到了一起，通过一个共享智能指针来管理这些条件。

## 2.`explicit ThreadPool(size_t threadCount = 8) : pool_(std::make_shared<Pool>())`
* `explicit`防止构造函数发生隐式类型转换
* `: pool_(std::make_shared<Pool>())`是成员初始化列表，用于初始化类的成员 `pool_`
* `std::make_shared<Pool>()`创建一个动态分配的 `Pool` 对象，并用 `shared_ptr` 接管它
* 这里推荐使用 `make_shared` 而不是 `new`，因为：更高效（一次分配内存即可，避免多次分配）、更安全（避免内存泄漏）、更简洁

## 3.`std::lock_guard<std::mutex>`和`std::unique_lock<std::mutex>`
* 简单加锁用 `lock_guard`，需要手动 unlock/wait/转移则用 `unique_lock`。
* `lock_guard`：最轻量、简单、首选（作用域内自动加/解锁）。
* `unique_lock`：功能更强（可手动 unlock/relock，支持 condition_variable），但稍微重一点。

## 4.为什么用模板（`template <typename T>`）？
因为我们希望支持各种可调用对象作为任务：
* `void(*)()` 形式的函数指针
* `std::function<void()>`
* `lambda` 表达式（捕获也可以）
* 仿函数（重载了 `operator()` 的类对象）  

如果不用模板，只能写成 `std::function<void()> task`，这样虽然可以，但：
* `std::function` 有一定性能开销（类型擦除）
* 无法完美转发可调用对象（如移动 `lambda`）  

所以用模板 + 完美转发，性能最好，也最灵活。

## 5.万能引用（T&& task）
无论传入的是左值还是右值，我们都能接收，并保持原本特性！

## 6.为什么用 `emplace()` 而不是 `push()`？
`push(x)` 会先构造一个临时对象 → 再复制进去  
`emplace(x)` 会直接在队列内部原地构造（没有多余拷贝）  
性能更好！特别是在处理 `lambda` 或复杂对象时更重要。  

## 7.`std::forward<T>(task)` 是用来干嘛的？
这是完美转发的核心:
* 如果 `task` 原本是右值 → `forward` 会当做右值传递
* 如果 `task` 原本是左值 → `forward` 会当作左值传递  
这么做可以避免不必要的复制，特别是在添加大任务对象时。保持 `task` 原本的“值类别”（左值/右值）进行传递,所以是高性能写法。

## 8.什么是RAII？
RAII是Resource Acquisition Is Initialization（资源获取即初始化）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

## 9.为什么要使用连接池？
* 由于服务器需要频繁地访问数据库，即需要频繁创建和断开数据库连接，该过程是一个很耗时的操作，也会对数据库造成安全隐患。
* 在程序初始化的时候，集中创建并管理多个数据库连接，可以保证较快的数据库读写速度，更加安全可靠。

## 10.连接池的实现
在连接池的实现中，使用到了信号量来管理资源的数量；而锁的使用则是为了在访问公共资源的时候使用。所以说，无论是条件变量还是信号量，都需要锁。  
不同的是，信号量的使用要先使用信号量sem_wait再上锁，而条件变量的使用要先上锁再使用条件变量wait。