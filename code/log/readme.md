# 日志系统

## 1.blockqueue.h
实现线程安全的队列，在日志系统中，一个线程写日志消息到队列，另一个线程从队列写入文件(生产者/消费者模型)  
阻塞队列采用deque实现。若MaxCapacity为0，则为同步日志，不需要阻塞队列。  
| 角色   | 对应操作          | 线程行为     | 使用变量                        |
| ---- | ------------- | -------- | --------------------------- |
| 生产者  | `push_back()` | 队满就等待    | `condProducer_`             |
| 消费者  | `pop()`       | 队空就等待    | `condConsumer_`             |
| 线程安全 | `mutex`       | 所有操作加锁   | `mtx_`                      |
| 程序退出 | `Close()`     | 通知所有线程退出 | `isClose_` + `notify_all()` |

## 2.阻塞队列在日志中的作用
在 log 系统中：  
主线程（业务线程）快速写日志字符串 → 放入 BlockDeque  
日志线程（写文件线程）不停 pop → 写入磁盘  
好处：
* 业务线程不会因为写文件阻塞
* 日志集中写入，提高写盘效率
* 多线程安全

## 3.lock.h
log.h 设计思想总结
* 使用单例模式，保证整个程序只有一个日志对象
* 支持同步 / 异步写日志（用阻塞队列 + 后台线程）
* 自动按日期和行数分日志文件
* 使用 Buffer 优化性能，减少多次 write 操作
* 通过宏封装调用，使用非常方便

## 4.lock.h中宏定义解析
`#define LOG_BASE(level, format, ...) \`
* `#define`：定义预处理宏。
* `LOG_BASE`：宏名，接收参数 level, format, ...。
* `...`：表示这是可变参数宏（variadic macro），允许像 `LOG_BASE(1, "%s", s)` 或 `LOG_BASE(1, "hi")` 两种用法。
* 行尾的 `\`：续行符，告诉预处理器宏定义在下一行继续（每一行末尾必须有 `\`，否则宏定义在该行结）。  
如果没有 `\`，宏只会包含到该行，后面的代码会报编译错误或产生意想不到的行为。  

`do { ... } while (0);`  
这是经典的宏惯用写法，目的有两个：
* 1.把宏扩展为单个语句：允许用户像写普通语句那样写 `if (cond) LOG_INFO(...); else ...` 而不会破坏 if/else 的配对。  
如果不加 `do{ }while(0)`，宏体是多条语句，写在 if 没有大括号的情形会导致语法错误或逻辑错误。
* 2.局部作用域：在 `do{}` 内定义的局部变量（例如 Log* log）不会泄漏到外部作用域。  
`while(0)` 永远不循环，等价于一次执行块。  

为什么宏里要同时 `write()` 和 `flush()`？
* `write()`：把格式化日志写入 Buffer 或者异步队列。
* `flush()`：  
在同步模式：会 `fflush(fp_)`，保证日志立刻写到磁盘（适合调试或崩溃时看日志）。  
在异步模式：会通知写线程立即处理队列（通过 deque_->flush()），减少日志延迟。
* 这样既能保证简单场景下“写就立刻落盘”，又能兼容异步高性能场景（`flush()` 的实现会根据模式选择不同策略）。  
注意：频繁 `flush()` 会降低吞吐（会增加 fsync/fflush 开销），但在这个实现里，异步模式 `flush()` 只是唤醒消费者，不会每次都强制磁盘同步。