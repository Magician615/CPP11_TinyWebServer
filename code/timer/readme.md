# 定时器系统

## 1.定时器介绍
网络编程中除了处理IO事件之外，定时事件也同样不可或缺。在web服务器中需要这样一个系统，定时剔除掉长时间不动的空闲用户，避免他们占着茅坑不拉屎，耗费服务器资源。  
一般的做法是将每个定时事件封装成定时器，并使用某种容器类数据结构将所有的定时器保存好，实现对定时事件的统一管理。常用方法有排序链表、红黑树、时间堆和时间轮。这里使用的是时间堆。  
时间堆的底层实现是由小根堆实现的。小根堆可以保证堆顶元素为最小的。

## 2.小根堆详解
传统的定时方案是以固定频率调用起搏函数`tick`，进而执行定时器上的回调函数。而时间堆的做法则是将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔，当超时时间到达时，处理超时事件，然后再次从剩余定时器中找出超时时间最小的一个，依次反复即可。  
当前系统时间：8:00  
1号定时器超时时间：8:05  
2号定时器超时时间：8:08  
设置心搏间隔：8:05-8:00=5  
5分钟到达后处理1号定时器事件，再根据2号超时时间设定心搏间隔。  
为了后面处理过期连接的方便，我们给每一个定时器里面放置一个回调函数，用来关闭过期连接。  
为了便于定时器结点的比较，主要是后续堆结构的实现方便，我们还需要重载比较运算符。

## 3.用到的C++11的时间新特性
（1）`std::chrono::high_resolution_clock`：
* `duration`（一段时间）
* `time_point`（时间点）  

（2）一般获取时间点是通过clock时钟获得的，一共有3个：
* `high_resolution_clock`
* `system_clock`
* `steady_clock`  

（3）`high_resolution_clock`：  
他有一个 `now()` 方法，可以获取当前时间。注意：`std::chrono::high_resolution_clock`返回的时间点是按秒为单位的。  

（4）`std::chrono::milliseconds`：  
表示毫秒，可用于`duration<>` 的模板类，举例：`chrono::duration_cast<milliseconds>`

## 4.设计思想
| 功能              | 作用                          |
| --------------- | --------------------------- |
| 使用小顶堆           | O(log n) 管理所有连接的超时          |
| 每个连接创建一个定时器     | 避免长时间无数据占用资源                |
| 超时调用回调函数        | 关闭连接（节省内存与线程）               |
| `GetNextTick()` | 配合 `epoll_wait(timeout)` 使用 |

## 5.小根堆设计为什么不用 `priority_queue` 而是 `vector`？
`priority_queue`不支持以下内容：
* 按 id 快速查找并删除/更新任意定时器（不是堆顶）
* 需要 id → 堆索引 的双向映射以实现 O(log n) 的更新/删除
* 更灵活地控制“删除某个非堆顶节点”的策略  
因此：为了支持按 id 的删除/调整以及保持高效，用 `vector` + `unordered_map` 维护堆是合适的选择。`priority_queue` 更适合只需“push/pop top”的场景。